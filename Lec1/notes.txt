âœ… 1. Single-thread vs Multi-thread
Single-threaded: JS executes one task at a time (main thread).

Multi-threaded: True parallel execution using Web Workers (in browsers).

ðŸ”¹ Web Workers:
Run JS in background thread, avoids UI freezing.
Used for:

CPU-heavy tasks (loops, image processing, parsing)

âœ… 2. Async in JS (Promises, async/await, setTimeout)
Used to handle non-blocking tasks:

Network requests

Background timers

Large calculations (if with Web Worker)

File reading/parsing (CSV/JSON)

âœ… 3. What is a Thread?
A thread is a path of execution.

JS uses one main thread.

Web Workers create extra threads for heavy tasks.

âœ… 4. Horizontal vs Vertical Scaling
Type	Meaning
Vertical	Upgrade one server's CPU/RAM
Horizontal	Add more servers (Node.js: clustering, PM2, load balancing)

âœ… 5. Latency vs Throughput
Term	Meaning
Latency	Time to handle one request
Throughput	Total requests handled per second

âœ… 6. JS: Compiled or Interpreted?
Originally interpreted

Now uses JIT (Just-In-Time) compilation via engines like V8

âœ… 7. JS: Sync or Async?
JS is synchronous by default

Becomes asynchronous using:

setTimeout, fetch, Promise, async/await

Managed by the Event Loop

ðŸ” Difference: Sync vs Async vs Multithreading
Concept	Parallel?	Blocking?	JS Example
Synchronous	âŒ No	âœ… Yes	Regular code
Asynchronous	âœ… Looks like	âŒ No	setTimeout, fetch
Multithreading	âœ… Yes	âŒ Depends	Web Workers

ðŸ”¹ JavaScript Hoisting
Hoisting: JS moves declarations to top of scope.

Only works for:

var (value = undefined)

Function declarations

ðŸ”¹ Temporal Dead Zone (TDZ)
Applies to let and const

Accessing before initialization = âŒ ReferenceError

js
Copy
Edit
console.log(x); // âŒ
let x = 10;
ðŸ”¹ Arrow Functions
Shorter syntax using =>

No own this, arguments, or super

Lexically bound this

js
Copy
Edit
const add = (a, b) => a + b;
Feature	Arrow Function	Regular Function
this	Lexical (outer)	Dynamic (depends)
Hoisting	âŒ Not hoisted	âœ… Hoisted
Syntax	Concise	Traditional

ðŸ”¹ Function Expression
A function assigned to a variable

Not hoisted like declarations

Can be anonymous or named

js
Copy
Edit
const greet = function(name) {
  return `Hello, ${name}`;
};
ðŸ”¹ Anonymous Functions
Functions with no name

Common in callbacks, IIFEs

js
Copy
Edit
setTimeout(function() {
  console.log("Hello");
}, 1000);
âœ… Summary Table
Concept	Description	Hoisted?
Hoisting	Moves declarations (not initializations)	âœ… var, fn
TDZ	Accessing let/const before init â†’ error	âŒ Error
Arrow Function	Short, no this/arguments	âŒ Not hoisted
Anonymous Func	Used in expressions/callbacks	âŒ Depends
Function Expr	Function assigned to a variable	âŒ Not hoisted

ðŸ”„ this Behavior Examples
js
Copy
Edit
function show() {
  console.log(this); // Global (window in browser)
}

const user = {
  name: "Palkit",
  sayHi() {
    console.log(this.name); // "Palkit"
  }
};

const user2 = {
  name: "Ravi",
  greet: () => {
    console.log(this.name); // undefined (arrow uses outer `this`)
  }
};

function greet() {
  console.log(this.name);
}
const person = { name: "Neha" };
greet.call(person); // "Neha"




Final Closure Recap
Closure is:
âž¤ Function + Its outer scope (preserved in Heap)

Why Closure works:
âž¤ Because inner function still has reference to outer variable, JavaScript's engine keeps it in memory (heap)

JavaScript Engine handles:
âž¤ Stack for execution
âž¤ Heap for variable/closure storage
âž¤ Garbage Collection to remove unused variables

ðŸ‘‡ Ask Yourself These to Spot Closure:

Is function returned from another function?	âž¤ Closure!
Is function using variable from parent?	âž¤ Closure!
Is that parent function already done?	âž¤ Closure!